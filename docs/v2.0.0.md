<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>[`NuGet - RabbitMQ.Client`] [<span style='color:#008B00'>[👓 官方说明 ]</span>](https://www.rabbitmq.com/client-libraries/dotnet-api-guide#limitations ':target=_blank')
>
>(`RabbitMQ`) 官方建议连接管理如下：
>
>- <span style='color:red'>[`Connection`单例模式 - 线程安全 ]</span> 应用程序应在启动时建立连接 [ 应在整个生命周期内复用该连接 ]
>
>- <span style='color:red'>[`RabbitMQ`中的`Channel`是`AMQP`协议中的虚拟连接，非线程安全：每个`Channel`都有自己的状态和缓冲区 ]</span> 
>
>  <span style='color:red'>[ 如果多个线程同时操作同一个`Channel`，会导致协议帧交错(`frame interleaving`) - 从而引发严重的协议错误 ]</span>
>
><br/>
>
><span style='color:Blue'>[ 最佳实践 ]</span>
>
>- 发布消息：每个线程独立`Channel`
>
>- 消费消息：尽量独立`Channel`<span style='color:red'>[ 必须共享时用互斥 ]</span>
>
>  <span style='color:red'>[ 推荐用对象池：每次从池中获取`Channel`，用完归还，保证同一时刻只有一个线程使用某个`Channel`]</span>
>
>  <span style='color:red'>[ 注意事项：因`Connection`连接中断，所有基于该连接创建的`Channel`都会失效，无法继续使用 ]</span>
>
><br/>

<!-- tabs:start -->

#### **[ 单例 ]IConnection**

```csharp
# connstr: amqp://user:pass@hostName:port/vhost
ConnectionFactory factory = new ConnectionFactory();
// factory.HostName = "192.168.8.172";
// factory.VirtualHost = "/";
# 默认AMQP端口（ 非管理端口 ）
factory.Port = 5672;
factory.UserName = "root";
factory.Password = "888888";

# [ 连接超时时间 ] 建议设置为10~30秒
factory.RequestedConnectionTimeout = TimeSpan.FromSeconds(15);
# [ 连接心跳间隔 ] 建议设置为 30秒或更短 ( 防止连接假死 - 默认 1 分钟 )
factory.RequestedHeartbeat = TimeSpan.FromSeconds(30);

factory.AutomaticRecoveryEnabled = true;                    // [ 自动恢复连接 ]
factory.NetworkRecoveryInterval = TimeSpan.FromSeconds(10); // 每 10 秒尝试一次自动恢复

# [ 读写超时时间 ]
factory.SocketReadTimeout = TimeSpan.FromSeconds(15);
factory.SocketWriteTimeout = TimeSpan.FromSeconds(15);

var endpoints = new System.Collections.Generic.List<AmqpTcpEndpoint> {
    new AmqpTcpEndpoint("192.168.8.172")
};
IConnection conn = await factory.CreateConnectionAsync(endpoints);

// await conn.CloseAsync();
// await conn.DisposeAsync();


```



#### **[ ☢ 通道 ]IChannel **

```csharp
public class ChannelPooledObjectPolicy : PooledObjectPolicy<IChannel>
{

     private readonly IConnection _connection;
     public ChannelPooledObjectPolicy(IConnection connection)
     {
          _connection = connection;
     }

     public override IChannel Create()
     {
          var channel = _connection.CreateChannelAsync().GetAwaiter().GetResult();
          return channel;
     }

     public override bool Return(IChannel obj)
     {
         
          # 只归还打开的通道 ( 超出对象容器：自动 IDisposable )
          // await channel.CloseAsync();
          // await channel.DisposeAsync();
          return obj.IsOpen;
         
     }
     
}


```

```csharp
IConnection conn = await factory.CreateConnectionAsync(endpoints);
DefaultObjectPool<IChannel> pool = new DefaultObjectPool<IChannel>(new ChannelPooledObjectPolicy(conn));

IChannel channel = pool.Get();
try
{
     Console.WriteLine("通道是否正常打开：" + channel.IsOpen);
}
finally
{

     pool.Return(channel);
}

channel = pool.Get();
try
{
     Console.WriteLine("通道是否正常打开：" + channel.IsOpen);
}
finally
{

     pool.Return(channel);
}


```





<!-- tabs:end -->
