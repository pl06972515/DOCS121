<br/>

<!-- tabs:start -->

#### **IChannel**

```csharp
public interface IChannel : IAsyncDisposable, IDisposable
{
     
     # [ 事件触发 ] Connection 连接恢复
     event AsyncEventHandler<AsyncEventArgs> RecoverySucceededAsync;
     # [ 事件触发 ] Connection 连接销毁 ( 包括异常断开、手动关闭等情况时触发 )
     event AsyncEventHandler<ShutdownEventArgs> ConnectionShutdownAsync;
    
     # [ A.1 ] 声明队列 ( 存在则返回 )
     Task<QueueDeclareOk> QueueDeclareAsync(
         string queue, 
         bool durable,    // [ 是否持久 ] true: 队列的元数据会被写入磁盘 ( RabbitMQ 重启, 保证依然存在 )
         bool exclusive,  // [ 是否排他 ] true：只允许当前连接访问 ( 连接断开后队列自动删除 )
         bool autoDelete, // [ 是否自动删除 ] true：最后一个消费者断开连接后自动删除队列
         IDictionary<string, object?>? arguments = null,  // [ 高级配置 ] 如队列最大长度等
         bool passive = false,                            // false：正常声明队列 ( 不存在则创建 )
         bool noWait = false,                             // false: 客户端会等待服务器确认声明成功 ( 如果声明失败，会立即抛出异常 )
         CancellationToken cancellationToken = default);
    
     # [ A.2 ] 声明交换机 ( 存在则返回 )
     public static Task ExchangeDeclareAsync(this IChannel channel,
         string exchange,
         # [ 类型 ] ExchangeType.Direct | Fanout | Headers | Topic
         string type, 
         bool durable = false,     // [ 是否持久化 ] true: 交换机的元数据会被写入磁盘 ( RabbitMQ 重启, 保证依然存在 )
         bool autoDelete = false,  // [ 是否自动删除 ] true: 当没有队列绑定到该交换机时, 交换机会自动删除
         IDictionary<string, object?>? arguments = null, // [ 高级配置 ] 如延迟交换机等扩展功能
         bool noWait = false,                            // [ 等待确认 ] false: 客户端会等待服务器确认声明成功 ( 如果声明失败，会立即抛出异常 )
         CancellationToken cancellationToken = default)
    
     # [ A.3 ] 路由绑定 ( 交换机 <=> 队列 )
     Task QueueBindAsync(
         string queue, 
         string exchange, 
         string routingKey,
         IDictionary<string, object?>? arguments = null, // [ 高级配置 ] 如延迟交换机等扩展功能
         bool noWait = false,                            // [ 等待确认 ] false: 客户端会等待服务器确认声明成功 ( 如果声明失败，会立即抛出异常 )
         CancellationToken cancellationToken = default)
         
     # [ B ] 发送消息 ( Producer - 生产者 )
     ValueTask BasicPublishAsync<TProperties>(
         string exchange,   // 交换机 ( "": 默认交换机 ) 
         string routingKey, // 路由键 ( 针对简单 | 工作队列此处代表：队列名称 )
         # [ 消息确认 ]
         # - true: 如果交换机存在, 当消息无法根据 routingKey 路由到任何队列时 
         #         ( RabbitMQ 将消息退回给生产者 : 触发事件 IChannel.BasicReturnAsync, 事件未订阅则抛出异常 )
         #         ( 如果交换机不存在: RabbitMQ 会直接关闭通道并抛出异常 - 不会触发 IChannel.BasicReturnAsync 事件 )
         # - false: 消息将被 RabbitMQ 直接丢弃 ( 生产者不会收到任何通知 )
         bool mandatory, 
         TProperties basicProperties,  // [ 消息属性 ] BasicProperties 
         ReadOnlyMemory<byte> body,    // [ 消息内容 ]
         CancellationToken cancellationToken = default) where TProperties : IReadOnlyBasicProperties, IAmqpHeader;
    
     # [ C ] 消费订阅 ( Consumer - 注册监听 )
     Task<string> BasicConsumeAsync(
         string queue, 
         bool autoAck,       // [ 是否自动 ACK  ]
         string consumerTag, // [ 消费者唯一标识 ]
         
         /// <summary>
         /// [ 控制行为：自己发布自己消费 ]
         ///   - true:  不会消费本连接( 即当前 IConnection 实例 )自己发布的消息 【只消费其他连接发布的消息】
         ///   - false: 消费所有消息 ( 包括本连接自己发布的消息 )
         ///   
         /// </summary>
         bool noLocal,   
         /// <summary>
         /// [ 控制行为: 是否独占队列 ]
         ///   - true: 注册消费者时, 此队列只由本连接( 即当前 IConnection 实例 )消费者独占消费 ( 如果有其他消费者尝试消费该队列 - 则报错 )
         ///   - false: 非独占
         ///   
         /// </summary>
         bool exclusive,
         IDictionary<string, object?>? arguments,
         # [ 消费者注册 ]
         IAsyncBasicConsumer consumer,           
         CancellationToken cancellationToken = default);
    
}


```



#### **[ ☢ 消息属性 ]BasicProperties**

```csharp
public sealed class BasicProperties : IBasicProperties, IAmqpHeader
{
    
     public IDictionary<string, object?>? Headers { get; set; }
     public string? ContentType { get; set; }
     public string? ContentEncoding { get; set; }
     
     public string? MessageId { get; set; }       // 唯一标识
     public string? Type { get; set; }            // 消息类型
     public string? AppId { get; set; }           // 消息来源( 标识消息来源应用 )
    
     public AmqpTimestamp Timestamp { get; set; } // 消息时间戳
     public string? Expiration { get; set; }      // 过期时间 ( 字符串: 单位毫秒 )
     public byte Priority { get; set; }           // 消息优先级( 0~255 )
     
     # [ 是否持久化 ] true: 消息会被写入磁盘 ( RabbitMQ 重启, 保证消息不丢失 )
     public bool Persistent
     {
          get => DeliveryMode == DeliveryModes.Persistent;
          // DeliveryModes.Persistent: 持久化消息
          set => DeliveryMode = value ? DeliveryModes.Persistent : DeliveryModes.Transient;
     }
     
     # [ 消息关联 ] 业务标识 ( 可以用来标识某个业务流程或事务, 方便后续处理 )
     public string? CorrelationId { get; set; }
     # [ 标识集群 ]
     public string? ClusterId { get; set; }
     
     /*... 代码忽略 ...*/
    
}


```



#### **[ ☢ 消费者监听器 ]IAsyncBasicConsumer **

!> <span style='color:red'>自定义消费者 [ 需继承自`AsyncDefaultBasicConsumer`]</span>

```csharp
public interface IAsyncBasicConsumer
{
    
     IChannel? Channel { get; }
     
     # [ 监听 ] 消息队列
     Task HandleBasicDeliverAsync(
          string consumerTag,
         
          # [ 检测 ] 当前消息是否是[ 重复投递 ]
          # - false: 消息是第一次投递给消费者
          # - true:  消息是再次投递, 即之前已经投递过( NACK  )
          bool redelivered, 
          # [ 消息投递标签 ] RabbitMQ 为每个信道上的每条消息分配唯一的递增编号 ( 用于标识要确认的消息 )
          ulong deliveryTag,
          string exchange,    // [ 消息源 ] 交换机
          string routingKey,  // [ 消息源 ] 路由键
          IReadOnlyBasicProperties properties, // [ 消息源 ] BasicProperties
          ReadOnlyMemory<byte> body,           // [ 消息源 ] 消息内容
          CancellationToken cancellationToken = default(CancellationToken));

    
}


```



<!-- tabs:end -->



