<br/>

>[!WARNING|style: flat|label: 简要说明]
>
>- <span style='color:Blue'>[ 工作队列`Work Queues`]</span> 支持多个消费者(`Consumer`)
>
>   <span style='color:red'>[ 竞争消费：针对同一个队列，各个消费者将对同一条消息是竞争关系 - 谁先抢到该消息谁就处理 ]</span>
>
>   [<span style='color:#008B00'>[👓 官方说明 ]</span>](https://www.rabbitmq.com/tutorials#2-work-queues ':target=_blank')
>
>
> ![image-20250923211208379](wwwroot\docImages\image-20250923211208379.png)
>
>⚠<span style='color:red'>[ 此模式使用默认交换机`Default Exchange`：默认交换机的名称是空字符串，它是一个直连交换机 ]</span>
>
><br/>

<!-- tabs:start -->

#### **[ C# ]Producer**

```csharp
IConnection conn = await factory.CreateConnectionAsync(endpoints);
# [ 注意事项 ] 当连接 IConnection 断开后, 之前基于该连接创建的通道均不可用 [ 需要重新创建 ]
DefaultObjectPool<IChannel> pool = new DefaultObjectPool<IChannel>(new ChannelPooledObjectPolicy(conn));

async Task M1(IConnection conn, CancellationToken token)
{

     for (int i = 0; i < 10; i++)
     {

          IChannel channel = pool.Get();
          try
          {
               // [ 声明队列 ] Q1
               await channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);

               // [ 发布消息 ]
               string message = $"Hello World! {i}";
               ReadOnlyMemory<byte> body = System.Text.Encoding.UTF8.GetBytes(message);

               var properties = new BasicProperties
               {
                    Persistent = true,
                    ContentType = "text/plain",
                    ContentEncoding = "utf-8",

                    MessageId = Guid.CreateVersion7().ToString("N"),
                    CorrelationId = "0201-03",
                    Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds()),
                    AppId = "TConsoleApp",
                    Type = "Test"
               };
               await channel.BasicPublishAsync(exchange: "", routingKey: "Q1", false, basicProperties: properties, body: body);
               Console.WriteLine(" 已发送消息: {0}", message);

          }
          finally
          {
               pool.Return(channel);
          }
          await Task.Delay(3000);

     }

}

await M1(conn, CancellationToken.None);


```





#### **[ C# ]Consumer**

```csharp
# [ 消费者 ]
file class MessageConsumer : AsyncDefaultBasicConsumer
{
     
     public MessageConsumer(IChannel channel)
          : base(channel) { }
     
     public override async Task HandleBasicDeliverAsync(
          string consumerTag,
          ulong deliveryTag,
          bool redelivered,
          string exchange, string routingKey,
          IReadOnlyBasicProperties properties,
          ReadOnlyMemory<byte> body,
          CancellationToken cancellationToken = default)
     {
          string msg = Encoding.UTF8.GetString(body.ToArray());
          Console.WriteLine("收到消息: " + msg);

          # [ 手动 ] 消息确认
          await Channel.BasicAckAsync(deliveryTag, false, cancellationToken);
     }


}


```



```csharp
public sealed class MQBackgroundService : BackgroundService
{

     private readonly IConnection _conn;
     private IChannel? _channel;
     public MQBackgroundService(IConnection conn)
     {

          this._conn = conn;
          # [ 事件 ] 连接恢复成功
          _conn.RecoverySucceededAsync += this.RecoverySucceededAsync;
          _conn.ConnectionShutdownAsync += ConnectionShutdownAsync;

     }

     private async Task RecoverySucceededAsync(object sender, AsyncEventArgs @event)
     {
          Console.WriteLine("MQ 连接恢复 ...");
          await this.CreateAndStartConsumerAsync(CancellationToken.None);
     }
     private Task ConnectionShutdownAsync(object sender, ShutdownEventArgs @event)
     {
          Console.WriteLine("MQ 连接中断 ...");
          this._channel?.Dispose();
          return Task.CompletedTask;
     }

     protected override async Task ExecuteAsync(CancellationToken stoppingToken)
     {

          await this.CreateAndStartConsumerAsync(stoppingToken);
          /// <summary>
          /// [ 保持消费者持续运行 ]
          /// 在 RabbitMQ 消费者场景下, BasicConsumeAsync 事件注册了一个消息消费者后 [ 方法本身并不会阻塞或持续运行 ] 
          /// 因此：M2 方法会直接执行到 finally 块并归还 channel 【导致消费者生命周期过短, 无法持续消费消息】
          ///   
          /// </summary>
          await Task.Delay(Timeout.Infinite, stoppingToken);

     }

     private async Task CreateAndStartConsumerAsync(CancellationToken stoppingToken)
     {

          this._channel?.Dispose();
          Interlocked.Exchange(ref this._channel, await _conn.CreateChannelAsync());
          var consumer = new MessageConsumer(this._channel!);

          # [ A ] 声明队列 Q1
          await this._channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);
          # [ B ] 注册消费者
          await this._channel!.BasicConsumeAsync(
              queue: "Q1",
              autoAck: false,
              consumerTag: "Email:Consumer",
              noLocal: false,
              exclusive: false,
              arguments: null,
              consumer: consumer,
              cancellationToken: stoppingToken
          );
          Console.WriteLine("MQ 消费者已注册!");

     }

     public override void Dispose()
     {
         
          base.Dispose();
          this._channel?.Dispose();
          
          this._conn.RecoverySucceededAsync -= this.RecoverySucceededAsync;
          this._conn.ConnectionShutdownAsync -= this.ConnectionShutdownAsync;
          
     }


}


```

>```csharp
>async Task M2(IConnection conn, CancellationToken token)
>{
>
>      MQBackgroundService service = new MQBackgroundService(conn);
>      await service.StartAsync(token);
>     
>}
>
>await M1(conn, CancellationToken.None);
>
>```
>
>
>
>



<!-- tabs:end -->
