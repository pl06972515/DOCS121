<br/>

<!-- tabs:start -->

#### **[ 中间件 ]AuthorizationMiddleware**

```csharp
public class AuthorizationMiddleware
{
   
     private readonly RequestDelegate _next;
     private readonly IAuthorizationPolicyProvider _policyProvider;
     public AuthorizationMiddleware(RequestDelegate next, IAuthorizationPolicyProvider policyProvider);

     public async Task Invoke(HttpContext context)
     {
       
          var endpoint = context.GetEndpoint();
          if (endpoint != null)
              context.Items["__AuthorizationMiddlewareWithEndpointInvoked"] = "OK"; // [ 终结点 ] 路由元数据安全检查
         
          AuthorizationPolicyBuilder? policyBuilder = null;
            
          # [ A ][ 终节点元数据 ] IAuthorizeData ( AuthorizeAttribute )
          IReadOnlyList<IAuthorizeData> authorizeDatas = endpoint?.Metadata.GetOrderedMetadata<IAuthorizeData>() 
                                                                  ?? Array.Empty<IAuthorizeData>();
            
          bool useDefaultPolicy = true;
          foreach (IAuthorizeData authorizeDatum in authorizeDatas)
          {
              
              if (policyBuilder == null)
                  policyBuilder = new AuthorizationPolicyBuilder();
                
              // [ A ] 根据策略键( IAuthorizeData.Policy ) -> 获取策略组
              if (!string.IsNullOrWhiteSpace(authorizeDatum.Policy))
              {
                   AuthorizationPolicy policy = await this._policyProvider.GetPolicyAsync(authorizeDatum.Policy).ConfigureAwait(false);
                   if (policy == null)
                       throw new InvalidOperationException();
                   
                   policyBuilder.AddRequirements(policy.Requirements);
                   useDefaultPolicy = false;
              }
                
              // [ B ] 根据角色 IAuthorizeData.Roles
              string[] rolesSplit = authorizeDatum.Roles?.Split(',');
              if (rolesSplit?.Length > 0)
              { 
                   policyBuilder.RequireRole(trimmedRolesSplit);
                   useDefaultPolicy = false;
              }
                
              // [ C ] 默认策略 [ 拒绝匿名用户访问 ]
              if (useDefaultPolicy) {
                  policyBuilder.AddRequirements(await policyProvider.GetDefaultPolicyAsync().ConfigureAwait(false));
                  useDefaultPolicy = false;
              }
             
          }
            
          # [ B ][ 终节点元数据 ] IAuthorizationRequirementData ( 扩展点: 自定义策略 )
          IReadOnlyList<IAuthorizationRequirementData> requirementData = 
                endpoint?.Metadata?.GetOrderedMetadata<IAuthorizationRequirementData>() 
                ?? Array.Empty<IAuthorizationRequirementData>();
          if (requirementData.Count > 0)
          {
              
               if (policyBuilder == null)
                   policyBuilder = new AuthorizationPolicyBuilder();
              
               foreach (var rd in requirementData)
               {
                    foreach (var r in rd.GetRequirements())
                        policyBuilder.AddRequirements(r);
               }
              
         }

         # [ C ][ 全局默认策略 ]
         if (policyBuilder == null)
         {
              
              AuthorizationPolicy fallbackPolicy = await this._policyProvider.GetFallbackPolicyAsync()
                                                                             .ConfigureAwait(false);
              if (fallbackPolicy != null)
              {
                    policyBuilder = new AuthorizationPolicyBuilder();
                    policyBuilder.AddRequirements(fallbackPolicy.Requirements);
                 
              } else {
                  
                   await _next(context);
                   return;
                  
              }
             
         }
             
         # [ D ][ 终节点 - 读取元数 ] AllowAnonymousAttribute ( 是否允许匿名 )
         if (endpoint?.Metadata.GetMetadata<IAllowAnonymous>() != null)
         {
              await _next(context);
              return;
         }
         
         # [ E ] 根据策略组 -> 请求授权
         AuthorizationPolicy policy = policyBuilder.Build();
         IEnumerable<IAuthorizationRequirement>? requirements = policy?.Requirements;
          
         IAuthorizationService _Services = context.RequestServices.GetRequiredService<IAuthorizationService>();
         AuthorizationResult result = await _Services.AuthorizeAsync(context.User, context, requirements);
         if(result.Succeeded == false)
         {
              
               # [ 获取 ] 请求认证结果
               AuthenticateResult AuthenticateResult = context.Features.Get<IAuthenticateResultFeature>()
                   												      ?.AuthenticateResult ?? AuthenticateResult.NoResult();
               if(AuthenticateResult.Succeeded)
                   await context.ForbidAsync();    // [ A ][ 请求已认证 ] 质询拒绝: 无权访问 - 状态码 403
               else 
                   await context.ChallengeAsync(); // [ B ][ 请求未认证 ] 质询验证: 无效票据,匿名请求/票据过期 - 状态码 401 
             
               return;
              
         } 
     
         await _next(context);
         
         /*... 代码忽略 ...*/
               
     }

}


```



#### **[ 扩展点 ]AuthorizationAppBuilderExtensions**

```csharp
public static class AuthorizationAppBuilderExtensions
{
    
      public static IApplicationBuilder UseAuthorization(this IApplicationBuilder app)
      {
           
           if (app.ApplicationServices.GetService(typeof(AuthorizationPolicyMarkerService)) == null)
               throw InvalidOperationException();
          
           // [ 启用授权策略 ]
           app.Properties["__AuthorizationMiddlewareSet"] = true;
           return app.UseMiddleware<AuthorizationMiddleware>();
      }
    
}


```



<!-- tabs:end -->





