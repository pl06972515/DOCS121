<br/>

>[!WARNING|style: flat|label: ç®€è¦è¯´æ˜]
>
>- <span style='color:Blue'>[ å·¥ä½œé˜Ÿåˆ—`Work Queues`]</span> æ”¯æŒå¤šä¸ªæ¶ˆè´¹è€…(`Consumer`)
>
>   <span style='color:red'>[ ç«äº‰æ¶ˆè´¹ï¼šé’ˆå¯¹åŒä¸€ä¸ªé˜Ÿåˆ—ï¼Œå„ä¸ªæ¶ˆè´¹è€…å°†å¯¹åŒä¸€æ¡æ¶ˆæ¯æ˜¯ç«äº‰å…³ç³» - è°å…ˆæŠ¢åˆ°è¯¥æ¶ˆæ¯è°å°±å¤„ç† ]</span>
>
>   [<span style='color:#008B00'>[ğŸ‘“ å®˜æ–¹è¯´æ˜ ]</span>](https://www.rabbitmq.com/tutorials#2-work-queues ':target=_blank')
>
>
> ![image-20250923211208379](wwwroot\docImages\image-20250923211208379.png)
>
>âš <span style='color:red'>[ æ­¤æ¨¡å¼ä½¿ç”¨é»˜è®¤äº¤æ¢æœº`Default Exchange`ï¼šé»˜è®¤äº¤æ¢æœºçš„åç§°æ˜¯ç©ºå­—ç¬¦ä¸²ï¼Œå®ƒæ˜¯ä¸€ä¸ªç›´è¿äº¤æ¢æœº ]</span>
>
><br/>

<!-- tabs:start -->

#### **[ C# ]Producer**

```csharp
IConnection conn = await factory.CreateConnectionAsync(endpoints);
# [ æ³¨æ„äº‹é¡¹ ] å½“è¿æ¥ IConnection æ–­å¼€å, ä¹‹å‰åŸºäºè¯¥è¿æ¥åˆ›å»ºçš„é€šé“å‡ä¸å¯ç”¨ [ éœ€è¦é‡æ–°åˆ›å»º ]
DefaultObjectPool<IChannel> pool = new DefaultObjectPool<IChannel>(new ChannelPooledObjectPolicy(conn));

async Task M1(IConnection conn, CancellationToken token)
{

     for (int i = 0; i < 10; i++)
     {

          IChannel channel = pool.Get();
          try
          {
               // [ å£°æ˜é˜Ÿåˆ— ] Q1
               await channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);

               // [ å‘å¸ƒæ¶ˆæ¯ ]
               string message = $"Hello World! {i}";
               ReadOnlyMemory<byte> body = System.Text.Encoding.UTF8.GetBytes(message);

               var properties = new BasicProperties
               {
                    Persistent = true,
                    ContentType = "text/plain",
                    ContentEncoding = "utf-8",

                    MessageId = Guid.CreateVersion7().ToString("N"),
                    CorrelationId = "0201-03",
                    Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds()),
                    AppId = "TConsoleApp",
                    Type = "Test"
               };
               await channel.BasicPublishAsync(exchange: "", routingKey: "Q1", false, basicProperties: properties, body: body);
               Console.WriteLine(" å·²å‘é€æ¶ˆæ¯: {0}", message);

          }
          finally
          {
               pool.Return(channel);
          }
          await Task.Delay(3000);

     }

}

await M1(conn, CancellationToken.None);


```





#### **[ C# ]Consumer**

```csharp
# [ æ¶ˆè´¹è€… ]
file class MessageConsumer : AsyncDefaultBasicConsumer
{
     
     public MessageConsumer(IChannel channel)
          : base(channel) { }
     
     public override async Task HandleBasicDeliverAsync(
          string consumerTag,
          ulong deliveryTag,
          bool redelivered,
          string exchange, string routingKey,
          IReadOnlyBasicProperties properties,
          ReadOnlyMemory<byte> body,
          CancellationToken cancellationToken = default)
     {
          string msg = Encoding.UTF8.GetString(body.ToArray());
          Console.WriteLine("æ”¶åˆ°æ¶ˆæ¯: " + msg);

          # [ æ‰‹åŠ¨ ] æ¶ˆæ¯ç¡®è®¤
          await Channel.BasicAckAsync(deliveryTag, false, cancellationToken);
     }


}


```



```csharp
public sealed class MQBackgroundService : BackgroundService
{

     private readonly IConnection _conn;
     private IChannel? _channel;
     public MQBackgroundService(IConnection conn)
     {

          this._conn = conn;
          # [ äº‹ä»¶ ] è¿æ¥æ¢å¤æˆåŠŸ
          _conn.RecoverySucceededAsync += this.RecoverySucceededAsync;
          _conn.ConnectionShutdownAsync += ConnectionShutdownAsync;

     }

     private async Task RecoverySucceededAsync(object sender, AsyncEventArgs @event)
     {
          Console.WriteLine("MQ è¿æ¥æ¢å¤ ...");
          await this.CreateAndStartConsumerAsync(CancellationToken.None);
     }
     private Task ConnectionShutdownAsync(object sender, ShutdownEventArgs @event)
     {
          Console.WriteLine("MQ è¿æ¥ä¸­æ–­ ...");
          this._channel?.Dispose();
          return Task.CompletedTask;
     }

     protected override async Task ExecuteAsync(CancellationToken stoppingToken)
     {

          await this.CreateAndStartConsumerAsync(stoppingToken);
          /// <summary>
          /// [ ä¿æŒæ¶ˆè´¹è€…æŒç»­è¿è¡Œ ]
          /// åœ¨ RabbitMQ æ¶ˆè´¹è€…åœºæ™¯ä¸‹, BasicConsumeAsync äº‹ä»¶æ³¨å†Œäº†ä¸€ä¸ªæ¶ˆæ¯æ¶ˆè´¹è€…å [ æ–¹æ³•æœ¬èº«å¹¶ä¸ä¼šé˜»å¡æˆ–æŒç»­è¿è¡Œ ] 
          /// å› æ­¤ï¼šM2 æ–¹æ³•ä¼šç›´æ¥æ‰§è¡Œåˆ° finally å—å¹¶å½’è¿˜ channel ã€å¯¼è‡´æ¶ˆè´¹è€…ç”Ÿå‘½å‘¨æœŸè¿‡çŸ­, æ— æ³•æŒç»­æ¶ˆè´¹æ¶ˆæ¯ã€‘
          ///   
          /// </summary>
          await Task.Delay(Timeout.Infinite, stoppingToken);

     }

     private async Task CreateAndStartConsumerAsync(CancellationToken stoppingToken)
     {

          this._channel?.Dispose();
          Interlocked.Exchange(ref this._channel, await _conn.CreateChannelAsync());
          var consumer = new MessageConsumer(this._channel!);

          # [ A ] å£°æ˜é˜Ÿåˆ— Q1
          await this._channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);
          # [ B ] æ³¨å†Œæ¶ˆè´¹è€…
          await this._channel!.BasicConsumeAsync(
              queue: "Q1",
              autoAck: false,
              consumerTag: "Email:Consumer",
              noLocal: false,
              exclusive: false,
              arguments: null,
              consumer: consumer,
              cancellationToken: stoppingToken
          );
          Console.WriteLine("MQ æ¶ˆè´¹è€…å·²æ³¨å†Œ!");

     }

     public override void Dispose()
     {
         
          base.Dispose();
          this._channel?.Dispose();
          
          this._conn.RecoverySucceededAsync -= this.RecoverySucceededAsync;
          this._conn.ConnectionShutdownAsync -= this.ConnectionShutdownAsync;
          
     }


}


```

>```csharp
>async Task M2(IConnection conn, CancellationToken token)
>{
>
>      MQBackgroundService service = new MQBackgroundService(conn);
>      await service.StartAsync(token);
>     
>}
>
>await M1(conn, CancellationToken.None);
>
>```
>
>
>
>



<!-- tabs:end -->
