<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- [ 延迟队列 ] 消息在被发送到队列后，并不会立即被消费者消费 <span style='color:red'>[ 而是要等到指定的时间后才能被消费 ]</span>
>
>  <span style='color:Blue'>如：电商系统中，用户下单后如果长时间未支付，需要自动取消订单</span>
>
>  <span style='color:Blue'>可以在下单时将订单信息发送到延迟队列，设置延迟时间 (`如30分钟`) [ 如果`30`分钟后订单还未支付，消费者收到消息后自动关闭订单 ]</span>
>
>  <br/>
>
><span style='color:Blue'>[ 延迟队列实现思路 ]</span>
>
>- [`A`] 创建一个队列(`如 Q1.Delay`) <span style='color:red'>[ 设置`x-message-ttl`消息过期时间 - 不要有消费者直接消费此队列 ]</span>
>
>- [`B`] 死信队列：延迟队列的消息过期后 → 自动路由到死信队列<span style='color:red'> [ 消费者只监听死信队列，处理到期的消息 ]</span>
>
><br/>



```csharp
# [ 消费端 ]
public override async Task HandleBasicDeliverAsync(
      string consumerTag,
      ulong deliveryTag,
      bool redelivered,
      string exchange, string routingKey,
      IReadOnlyBasicProperties properties,
      ReadOnlyMemory<byte> body,
      CancellationToken cancellationToken = default)
{
     
      var orderId = Encoding.UTF8.GetString(body.ToArray());
      # [ A ] 查询订单状态 ( 已支付 ... )
      var status = await OrderService.GetOrderStatusAsync(orderId);
      if (status == "已支付")
      {
           await Channel.BasicAckAsync(deliveryTag, false, cancellationToken);
           return;
      }
    
      # [ B ] 查询订单状态 ( 未支付：取消订单 )
      await OrderService.CancelOrderAsync(orderId);
      await Channel.BasicAckAsync(deliveryTag, false, cancellationToken);
    
}


```

