<br/>

>[!WARNING|style: flat|label: 简要说明]
>
>(`RabbitMQ`) 消息可靠性主要涉及 <span style='color:red'>[ 消息的持久化、确认机制和防止消息丢失 ]</span>，以下是实现消息可靠性的关键措施：
>
>- <span style='color:Blue'>[ 故障情况`A`]</span> 消息未成功发送到消息队列 <span style='color:Blue'>( 生产者`Producer`)</span>
>
>   <span style='color:red'>解决方式1：消息确认模式(`Publisher Confirm`)</span>
>
>   解决方式2：配置备份交换机 ( 当消息无法投递到目标交换机时，自动将消息转发至备份交换机 - 避免消息丢失 )
>
>
> <br/>
>
>- <span style='color:Blue'>[ 故障情况`B`]</span> 消费端宕机或异常，导致消息未被成功消费 <span style='color:Blue'>( 消费者`Consumer`)</span>
>
>   <span style='color:red'>[`OK`消费成功 ] 消费端向服务器发送`ACK`( 确认信息 )</span> <span style='color:red'>[`RabbitMQ`收到`ACK`后，立即从队列中删除该消息，确保消息不会重复消费 ]</span>
>
>   <span style='color:red'>[`NO`消费失败 ] 消费端向服务器发送`NACK`( 否认信息 )</span> <span style='color:red'>[`RabbitMQ`收到`NACK`后，将消息重置为待消费状态，允许后续消费者重试消费 ]</span>
>
>   <span style='color:red'>[ 注意：如果消费端一直`NACK`并且`requeue: true`，消息会被无限次重新投递，造成死循环 ]</span>
>
>
><br/>

<!-- tabs:start -->

#### **[ Producer ]**

```csharp
public class ChannelPooledObjectPolicy : PooledObjectPolicy<IChannel>
{

     private readonly IConnection _connection;
     public ChannelPooledObjectPolicy(IConnection connection)
     {
          _connection = connection;
          
     }

     public override IChannel Create()
     {
          
          IChannel? channel = _connection.CreateChannelAsync().GetAwaiter().GetResult();
          channel.BasicReturnAsync += (sender, args) =>
          {

               # [ 事件关注 ] 消息确认 ( 消息有没有被路由到队列 )
               Console.WriteLine($"[ 消息未被路由到队列 ] " +
                    $"交换机: {args.ReplyCode}, " +
                    $"路由键: {args.RoutingKey}, " +
                    $"消息主体: {Encoding.UTF8.GetString(args.Body.ToArray())}, " +
                    $"响应状态: {args.ReplyCode}, " +
                    $"响应说明: {args.ReplyText}");

               return Task.CompletedTask;

          };
          channel.BasicNacksAsync += (sender, args) =>
          {

               # [ 事件关注 ] 消息已经被 RabbitMQ 接收, 但由于内部错误( 如磁盘写入失败、RabbitMQ 异常等 ) [ 消息未被持久化 ]
               Console.WriteLine($"[ 消息未被持久化 ] DeliveryTag: {args.DeliveryTag}, Multiple: {args.Multiple}, 时间: {DateTime.Now:O}");
               return Task.CompletedTask;

          };

          return channel;

     }

     public override bool Return(IChannel obj) => obj.IsOpen;

}


```

>```csharp
># [ 消息确认模式 ] 交换机 E2 存在, 但因路由键 Email1 不存在无法路由到队列 ( 触发 BasicReturnAsync )
>#   - mandatory = true: 如果交换机存在, 当消息无法根据 routingKey 路由到任何队列时 
>#                 ( RabbitMQ 将消息退回给生产者 : 触发事件 IChannel.BasicReturnAsync, 事件未订阅则抛出异常 )
>#                 ( 如果交换机不存在: RabbitMQ 会直接关闭通道并抛出异常 - 不会触发 IChannel.BasicReturnAsync 事件 )
>#   - mandatory = false: 消息将被 RabbitMQ 直接丢弃 ( 生产者不会收到任何通知 )
>await channel.BasicPublishAsync(exchange: "E2", routingKey: "Email1", mandatory: true, basicProperties: properties, body: body);
>
>```
>
>
>
>



#### **[ Consumer ]**

```csharp
public interface IChannel : IAsyncDisposable, IDisposable
{
    
     # [ 消息确认 ACK ]
     #  - deliveryTag: 消息投递标签 ( RabbitMQ 为每个信道上的每条消息分配唯一的递增编号 - 用于标识要确认的消息 )
     #  - multiple: 
     #    false：单条确认 ( 确认 = deliveryTag 的消息 )
     #	 true：批量确认 ( 确认 <= deliveryTag 的消息 )
     ValueTask BasicAckAsync(ulong deliveryTag, bool multiple, CancellationToken cancellationToken = default);
         
     # [ 消息否认 NACK ]
     #  - requeue: 
     #    false：被否认的消息会被直接丢弃 [ 如果有死信队列则进入死信队列 ]
     #	 true：被否认的消息会重新回到队列 ( 等待后续重新投递 ) [ 注意：因消息无限否认将造成死循环 ]
     ValueTask BasicNackAsync(ulong deliveryTag, bool multiple, bool requeue, CancellationToken cancellationToken = default);
     
}


```

>```csharp
>file class MessageConsumer : AsyncDefaultBasicConsumer
>{
>     
>      public MessageConsumer(IChannel channel)
>           : base(channel) { }
>
>      public override Task HandleChannelShutdownAsync(object channel, ShutdownEventArgs reason)
>      {
>           return base.HandleChannelShutdownAsync(channel, reason);
>      }
>      public override async Task HandleBasicDeliverAsync(
>           string consumerTag,
>           ulong deliveryTag,
>           bool redelivered,
>           string exchange, string routingKey,
>           IReadOnlyBasicProperties properties,
>           ReadOnlyMemory<byte> body,
>           CancellationToken cancellationToken = default)
>      {
>         
>           string msg = Encoding.UTF8.GetString(body.ToArray());
>           Console.WriteLine("收到消息: " + msg);
>
>           # [ 消息确认 ] ACK
>           await Channel.BasicNackAsync(deliveryTag, multiple:  false, requeue: true, cancellationToken);
>         
>      }
>
>}
>
>```
>
>
>
>



<!-- tabs:end -->
