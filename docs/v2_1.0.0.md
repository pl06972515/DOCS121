<br/>

<!-- tabs:start -->

#### **IChannel**

```csharp
public interface IChannel : IAsyncDisposable, IDisposable
{
     
     # [ 事件触发 ] Connection 连接恢复
     event AsyncEventHandler<AsyncEventArgs> RecoverySucceededAsync;
     # [ 事件触发 ] Connection 连接销毁 ( 包括异常断开、手动关闭等情况时触发 )
     event AsyncEventHandler<ShutdownEventArgs> ConnectionShutdownAsync;
    
     # [ A ] 创建队列 ( 存在则返回 )
     Task<QueueDeclareOk> QueueDeclareAsync(
         string queue, 
         bool durable,    // [ 是否持久 ] true: 持久化队列元数据  ( RabbitMQ 重启 - 保证依然存在 )
         bool exclusive,  // [ 是否排他 ] true：只允许当前连接访问 ( 连接断开后队列自动删除 )
         bool autoDelete, // [ 是否自动删除 ] true：最后一个消费者断开连接后自动删除队列
         
         # [ 高级配置 ]
         # - { "x-max-priority", int } - 消息最大优先级 ( 0 - 255 )
         # - { "x-max-length", int }   - 容量限制：队列消息数量到达上限 [ 立即将最早的消息 - 变为死信 ]
         # - { "x-message-ttl", int }  - 消息超时：超时未被消费的消息 - 变为死信
         IDictionary<string, object?>? arguments = null,
         
         bool passive = false, // false：队列创建 ( 不存在则创建 )
         bool noWait = false,  // false: 客户端会等待 MQ 确认是否创建成功 ( 如果创建失败 - 会立即抛出异常 )
         CancellationToken cancellationToken = default);
    
     # [ B ] 创建交换机 ( 存在则返回 )
     public static Task ExchangeDeclareAsync(this IChannel channel,
         string exchange,
         # [ 类型 ] ExchangeType.Direct | Fanout | Headers | Topic
         string type, 
         bool durable = false,     // [ 是否持久化 ] true: 持久化交换机元数据 ( RabbitMQ 重启 - 保证依然存在 )
         bool autoDelete = false,  // [ 是否自动删除 ] true: 当没有队列绑定到该交换机时 ( 交换机会自动删除 )
         
         # [ 高级配置 ] 如延迟交换机等扩展功能
         IDictionary<string, object?>? arguments = null, 
         # [ 等待确认 ] false: 客户端会等待 MQ 确认是否创建成功 ( 如果创建失败 - 会立即抛出异常 )          
         bool noWait = false,                          
         CancellationToken cancellationToken = default)
     
     # [ C ] 路由绑定 ( 交换机 <=> 队列 )
     Task QueueBindAsync(
         string queue, 
         string exchange, 
         string routingKey,
         IDictionary<string, object?>? arguments = null, // [ 高级配置 ] 如延迟交换机等扩展功能
         bool noWait = false,                            // [ 等待确认 ] false: 客户端会等待服务器确认声明成功 ( 如果声明失败，会立即抛出异常 )
         CancellationToken cancellationToken = default)
         
}


```

```csharp
public interface IChannel : IAsyncDisposable, IDisposable
{
     
     # [ A ] 发送消息 ( Producer - 生产者 )
     ValueTask BasicPublishAsync<TProperties>(
         string exchange,   // 交换机 ( "": 默认交换机 ) 
         string routingKey, // 路由键 ( 针对简单 | 工作队列此处代表：队列名称 )
         
         # [ 消息确认 ]
         # - true: 如果交换机存在 [ 但消息无法根据 routingKey 路由到任何队列 ] 
         #         ( MQ 将消息退回给生产者 : 触发事件 IChannel.BasicReturnAsync, 事件未订阅则抛出异常 )
         #         ( 如果交换机不存在: MQ 会直接关闭通道并抛出异常 - 不会触发 IChannel.BasicReturnAsync 事件 )
         # - false: 消息将被 RabbitMQ 直接丢弃 ( 生产者不会收到任何通知 )
         bool mandatory, 
         
         TProperties basicProperties,  // [ 消息属性 ] BasicProperties 
         ReadOnlyMemory<byte> body,    // [ 消息内容 ]
         CancellationToken cancellationToken = default) where TProperties : IReadOnlyBasicProperties, IAmqpHeader;
    
     # [ B ] 消费订阅 ( Consumer - 注册监听 )
     Task<string> BasicConsumeAsync(
         string queue, 
         bool autoAck,       // [ 是否自动 ACK  ]
         string consumerTag, // [ 消费者唯一标识 ]
         
         # [ 控制行为 ] 消费控制 
         # - true:  消费者不会收到由自己连接发布到队列的消息( 即当前 IConnection 实例 ) [ 只能消费其他连接发布的消息 ]
         # - false: 消费所有消息 ( 包括本连接自己发布的消息 )
         bool noLocal,   
         
         # [ 控制行为 ] 消费独占
         # - true:  只允许一个消费者订阅此队列 ( 如果有其他消费者尝试消费该队列 - 则报错 )
         # - false: 非独占
         bool exclusive,
         IDictionary<string, object?>? arguments,
         # [ 消费者注册 ]
         IAsyncBasicConsumer consumer,           
         CancellationToken cancellationToken = default);
    
}



```





#### **[ ☢ 消息属性 ]BasicProperties**

```csharp
public sealed class BasicProperties : IBasicProperties, IAmqpHeader
{
    
     public string? ContentType { get; set; }
     public string? ContentEncoding { get; set; }
     # [ 扩展信息 ] 在消息传递过程中携带额外的元数据 ( 消费者收到消息后可通过 Headers 读取这些扩展信息 )
     public IDictionary<string, object?>? Headers { get; set; }
     
     public string? MessageId { get; set; }       // 唯一标识
     public string? Type { get; set; }            // 消息类型
     public string? AppId { get; set; }           // 消息来源( 标识消息来源应用 )
     public AmqpTimestamp Timestamp { get; set; } // 创建时间
     
     # [ 过期时间 ] 字符串: 单位毫秒 ( 优先级高 )
     # [ 注意事项：超时未被消费的消息 - 会被队列丢弃或转发到死信队列 ]
     public string? Expiration { get; set; }
    
     # [ 消息优先级 ] 0 - 255 
     # [ 不能超过队列的 "x-max-priority" 优先级越高 - 越先被消费 ]
     public byte Priority { get; set; }  
     
     # [ 是否持久化 ] true: 消息会被写入磁盘 ( RabbitMQ 重启, 保证消息不丢失 )
     public bool Persistent
     {
          get => DeliveryMode == DeliveryModes.Persistent;
          // DeliveryModes.Persistent: 持久化消息
          set => DeliveryMode = value ? DeliveryModes.Persistent : DeliveryModes.Transient;
     }
     
     # [ 消息关联 ] 业务标识 ( 可以用来标识某个业务流程或事务, 方便后续处理 )
     public string? CorrelationId { get; set; }
     # [ 标识集群 ]
     public string? ClusterId { get; set; }
     
     /*... 代码忽略 ...*/
    
}


```



#### **[ ☢ 消费者监听器 ]IAsyncBasicConsumer **

!> <span style='color:red'>自定义消费者 [ 需继承自`AsyncDefaultBasicConsumer`]</span>

```csharp
public interface IAsyncBasicConsumer
{
    
     IChannel? Channel { get; }
     
     # [ 监听 ] 消息队列
     Task HandleBasicDeliverAsync(
          string consumerTag,
         
          # [ 检测 ] 当前消息是否是[ 重复投递 ]
          # - false: 消息是第一次投递给消费者
          # - true:  消息是重复投递 ( 即之前已经投递过, 但由于消费者 NACK（拒绝）或未确认, MQ 再次投递该消息 )
          bool redelivered, 
          # [ 消息编号 ] MQ 为每条消息分配的唯一递增编号 ( 仅在当前信道内唯一: 用于标识和确认 ack/nack 消息 )
          ulong deliveryTag,
         
          string exchange,    // [ 消息源 ] 交换机
          string routingKey,  // [ 消息源 ] 路由键
          IReadOnlyBasicProperties properties, // [ 消息属性 ] BasicProperties ( 只读 )
          ReadOnlyMemory<byte> body,           // [ 消息内容 ] 
         
          CancellationToken cancellationToken = default(CancellationToken));

    
}


```



<!-- tabs:end -->



