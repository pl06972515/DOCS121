<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>[`NuGet - RabbitMQ.Client`] [<span style='color:#008B00'>[👓 官方说明 ]</span>](https://www.rabbitmq.com/client-libraries/dotnet-api-guide#limitations ':target=_blank')
>
>(`RabbitMQ`) 官方建议连接管理如下：
>
>- <span style='color:red'>[`Connection`连接应长时间保持 - 单例模式 ]</span> 应用程序应在启动时建立连接，并在整个生命周期内复用该连接 <span style='color:red'>[ 不要为每次操作(`如发布消息`)都新建连接 ]</span>
>
>- <span style='color:red'>[`Channel`每个连接可创建多个通道 ]</span> 通道是轻量级的 <span style='color:red'>[ 建议每个线程或任务使用独立的通道，但共享同一个连接 ]</span>
>
>  <span style='color:red'>[`Channel`建议长时间复用，这样可以减少资源消耗，提高性能 ]</span>
>
><br/>

<!-- tabs:start -->

#### **[ 单例 ]IConnection**

```csharp
# connstr: amqp://user:pass@hostName:port/vhost
ConnectionFactory factory = new ConnectionFactory();
// factory.HostName = "192.168.8.172";
// factory.VirtualHost = "/";
# 默认AMQP端口（ 非管理端口 ）
factory.Port = 5672;
factory.UserName = "root";
factory.Password = "888888";

# [ 连接超时时间 ] 建议设置为10~30秒
factory.RequestedConnectionTimeout = TimeSpan.FromSeconds(15);
# [ 连接心跳间隔 ] 建议设置为 30秒或更短 ( 防止连接假死 - 默认 1 分钟 )
factory.RequestedHeartbeat = TimeSpan.FromSeconds(30);
factory.AutomaticRecoveryEnabled = true;  // [ 自动恢复连接 ]
factory.TopologyRecoveryEnabled = true;   // [ 拓扑恢复 ] 保证队列、交换机等自动恢复

# [ 读写超时时间 ]
factory.SocketReadTimeout = TimeSpan.FromSeconds(15);
factory.SocketWriteTimeout = TimeSpan.FromSeconds(15);

var endpoints = new System.Collections.Generic.List<AmqpTcpEndpoint> {
    new AmqpTcpEndpoint("192.168.8.172")
};
IConnection conn = await factory.CreateConnectionAsync(endpoints);

// await conn.CloseAsync();
// await conn.DisposeAsync();


```



#### **[ ☢ 通道 ]IChannel **

```csharp
public class ChannelPooledObjectPolicy : PooledObjectPolicy<IChannel>
{

     private readonly IConnection _connection;
     public ChannelPooledObjectPolicy(IConnection connection)
     {
          _connection = connection;
     }

     public override IChannel Create()
     {
          var channel = _connection.CreateChannelAsync().GetAwaiter().GetResult();
          return channel;
     }

     public override bool Return(IChannel obj)
     {
         
          # 只归还打开的通道 ( 超出对象容器：自动 IDisposable )
          // await channel.CloseAsync();
          // await channel.DisposeAsync();
          return obj.IsOpen;
         
     }
     
}


```

```csharp
IConnection conn = await factory.CreateConnectionAsync(endpoints);
DefaultObjectPool<IChannel> pool = new DefaultObjectPool<IChannel>(new ChannelPooledObjectPolicy(conn));
IChannel channel = pool.Get();
Console.WriteLine("通道是否正常打开："+ channel.IsOpen);


```





<!-- tabs:end -->
