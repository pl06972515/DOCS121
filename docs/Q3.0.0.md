<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 概念：当一个消息无法被消费 [ 它就变成了死信 ]，死信产生的原因大概有下面三种：
>
>   <span style='color:Blue'>[`A`] [ 消息超时`Expiration`]</span> 超时未被消费的消息
>
>   <span style='color:Blue'>[`B`] [ 消费者拒绝`NACK`]</span> 消费者拒绝消息(`requeue = false`)
>
>   <span style='color:Blue'>[`C`] [ 队列溢出 ]</span> 队列中消息数量到达限制<span style='color:red'> ( 先进先出原则：如到达上限，立即将最早的消息变为死信 )</span>
>
>
> <br/>
>
>- 死信的处理方式大致有下面三种：
>
>   [`A`] 丢弃：对不重要的消息直接丢弃 ( 不做处理 )
>
>   [`B`] 入库：把死信写入数据库 ( 日后处理 )
>
>   <span style='color:red'>[`C`] 监听：消息变成死信后进入死信队列 [ 我们专门设置消费端监听死信队列 - 做后续处理 ] [ 推荐模式 ]</span>
>
>
><br/>

<!-- tabs:start -->

#### **[ 死信队列 ]**

!> <span style='color:red'>死信队列应与主业务队列一一对应 [ 专用，不与其他业务队列共享 ]</span>

```csharp
# [ A ] 声明死信队列 Q1.DLX
await channel.QueueDeclareAsync("Q1.DLX", durable: true, exclusive: false, autoDelete: false, arguments: null);
# [ B ] 声明死信交换机 Q1.DLX.Channel
await channel.ExchangeDeclareAsync("Q1.DLX.Channel", ExchangeType.Direct, durable: true);
# [ C ] 路由绑定
await channel.QueueBindAsync(queue: "Q1.DLX", exchange: "Q1.DLX.Channel", routingKey: "Q1.DLX");


```



#### **[ 业务队列 ]**

```csharp
 await channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: new Dictionary<string, object> {
      # [ 配置 ] 限制长度 + 消息过期时间
      { "x-max-length", 1000 },
      { "x-message-ttl", 10000 },

      # [ 配置 ] 死信队列
      { "x-dead-letter-exchange", "Q1.DLX.Channel" },
      { "x-dead-letter-routing-key", "Q1.DLX" }
 }!);


```





<!-- tabs:end -->
