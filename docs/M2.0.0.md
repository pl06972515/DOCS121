<br/>

>[!WARNING|style: flat|label: ç®€è¦è¯´æ˜]
>
>- <span style='color:Blue'>[ å·¥ä½œé˜Ÿåˆ—`Work Queues`]</span> æ”¯æŒå¤šä¸ªæ¶ˆè´¹è€…(`Consumer`)
>
>   <span style='color:red'>[ ç«äº‰æ¶ˆè´¹ï¼šé’ˆå¯¹åŒä¸€ä¸ªé˜Ÿåˆ—ï¼Œå„ä¸ªæ¶ˆè´¹è€…å°†å¯¹åŒä¸€æ¡æ¶ˆæ¯æ˜¯ç«äº‰å…³ç³» - è°å…ˆæŠ¢åˆ°è¯¥æ¶ˆæ¯è°å°±å¤„ç† ]</span>
>
>   [<span style='color:#008B00'>[ğŸ‘“ å®˜æ–¹è¯´æ˜ ]</span>](https://www.rabbitmq.com/tutorials#2-work-queues ':target=_blank')
>
>
> ![image-20250923211208379](wwwroot\docImages\image-20250923211208379.png)
>
>âš <span style='color:red'>[ æ­¤æ¨¡å¼ä½¿ç”¨ç›´è¿äº¤æ¢æœº`ExchangeType.Direct`]</span>
>
><br/>

<!-- tabs:start -->

#### **[ ğŸŸ¨ C# ] Producer**

```csharp
IConnection conn = await factory.CreateConnectionAsync(endpoints);
# [ æ³¨æ„äº‹é¡¹ ] å½“è¿æ¥ IConnection æ–­å¼€å, ä¹‹å‰åŸºäºè¯¥è¿æ¥åˆ›å»ºçš„é€šé“å‡ä¸å¯ç”¨ [ éœ€è¦é‡æ–°åˆ›å»º ]
DefaultObjectPool<IChannel> pool = new DefaultObjectPool<IChannel>(new ChannelPooledObjectPolicy(conn));

async Task M1(IConnection conn, CancellationToken token)
{

     for (int i = 0; i < 10; i++)
     {

          IChannel channel = pool.Get();
          try
          {
               // [ å£°æ˜é˜Ÿåˆ— ] Q1
               await channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);

               // [ å‘å¸ƒæ¶ˆæ¯ ]
               string message = $"Hello World! {i}";
               ReadOnlyMemory<byte> body = System.Text.Encoding.UTF8.GetBytes(message);

               var properties = new BasicProperties
               {
                    Persistent = true,
                    ContentType = "text/plain",
                    ContentEncoding = "utf-8",

                    MessageId = Guid.CreateVersion7().ToString("N"),
                    CorrelationId = "0201-03",
                    Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds()),
                    AppId = "TConsoleApp",
                    Type = "Test"
               };
               
               # [ A ] exchange: "" ç›´è¿äº¤æ¢æœº
               # [ B ] routingKey: é˜Ÿåˆ—åç§°
               await channel.BasicPublishAsync(exchange: "", routingKey: "Q1", false, basicProperties: properties, body: body);
               Console.WriteLine(" å·²å‘é€æ¶ˆæ¯: {0}", message);

          }
          finally
          {
               pool.Return(channel);
          }
          await Task.Delay(3000);

     }

}

await M1(conn, CancellationToken.None);


```





#### **[ ğŸŸ¥ C# ] Consumer**

```csharp
# [ æ¶ˆè´¹è€… ]
file class MessageConsumer : AsyncDefaultBasicConsumer
{
     
     public MessageConsumer(IChannel channel)
          : base(channel) { }
     
     public override async Task HandleBasicDeliverAsync(
           string consumerTag,
         
           # [ æ£€æµ‹ ] å½“å‰æ¶ˆæ¯æ˜¯å¦æ˜¯[ é‡å¤æŠ•é€’ ]
           # - false: æ¶ˆæ¯æ˜¯ç¬¬ä¸€æ¬¡æŠ•é€’ç»™æ¶ˆè´¹è€…
           # - true:  æ¶ˆæ¯æ˜¯é‡å¤æŠ•é€’ ( å³ä¹‹å‰å·²ç»æŠ•é€’è¿‡, ä½†ç”±äºæ¶ˆè´¹è€… NACKï¼ˆæ‹’ç»ï¼‰æˆ–æœªç¡®è®¤, MQ å†æ¬¡æŠ•é€’è¯¥æ¶ˆæ¯ )
           bool redelivered, 
           # [ æ¶ˆæ¯ç¼–å· ] MQ ä¸ºæ¯æ¡æ¶ˆæ¯åˆ†é…çš„å”¯ä¸€é€’å¢ç¼–å· ( ä»…åœ¨å½“å‰ä¿¡é“å†…å”¯ä¸€: ç”¨äºæ ‡è¯†å’Œç¡®è®¤ ack/nack æ¶ˆæ¯ )
           ulong deliveryTag,
         
           string exchange,    // [ æ¶ˆæ¯æº ] äº¤æ¢æœº
           string routingKey,  // [ æ¶ˆæ¯æº ] è·¯ç”±é”®
           IReadOnlyBasicProperties properties, // [ æ¶ˆæ¯è½½ä½“ ] BasicProperties ( åªè¯» )
           ReadOnlyMemory<byte> body,           // [ æ¶ˆæ¯å†…å®¹ ] 
           CancellationToken cancellationToken = default)
     {
         
           string msg = Encoding.UTF8.GetString(body.ToArray());
           Console.WriteLine("æ”¶åˆ°æ¶ˆæ¯: " + msg);

           # [ æ‰‹åŠ¨ ] æ¶ˆæ¯ç¡®è®¤
           await Channel.BasicAckAsync(deliveryTag, false, cancellationToken);
         
     }

}


```



```csharp
public sealed class MQBackgroundService : BackgroundService
{

     private readonly IConnection _conn;
     private IChannel? _channel;
     public MQBackgroundService(IConnection conn)
     {

          this._conn = conn;
          # [ äº‹ä»¶ ] è¿æ¥æ¢å¤æˆåŠŸ
          _conn.RecoverySucceededAsync += this.RecoverySucceededAsync;
          _conn.ConnectionShutdownAsync += ConnectionShutdownAsync;

     }

     private async Task RecoverySucceededAsync(object sender, AsyncEventArgs @event)
     {
          Console.WriteLine("MQ è¿æ¥æ¢å¤ ...");
          await this.CreateAndStartConsumerAsync(CancellationToken.None);
     }
     private Task ConnectionShutdownAsync(object sender, ShutdownEventArgs @event)
     {
          Console.WriteLine("MQ è¿æ¥ä¸­æ–­ ...");
          this._channel?.Dispose();
          return Task.CompletedTask;
     }

     protected override async Task ExecuteAsync(CancellationToken stoppingToken)
     {

          await this.CreateAndStartConsumerAsync(stoppingToken);
          
          # [ ä¿æŒæ¶ˆè´¹è€…æŒç»­è¿è¡Œ ]
          # å› åœ¨ RabbitMQ æ¶ˆè´¹è€…åœºæ™¯ä¸‹, BasicConsumeAsync äº‹ä»¶æ³¨å†Œäº†ä¸€ä¸ªæ¶ˆæ¯æ¶ˆè´¹è€…å [ ä¸ä¼šé˜»å¡æˆ–æŒç»­è¿è¡Œ ] 
          await Task.Delay(Timeout.Infinite, stoppingToken)
                    .ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing);

     }

     private async Task CreateAndStartConsumerAsync(CancellationToken stoppingToken)
     {

          this._channel?.Dispose();
          Interlocked.Exchange(ref this._channel, await _conn.CreateChannelAsync());
          
          # [ A ] å£°æ˜é˜Ÿåˆ— Q1
          await this._channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);
         
          # [ B ] æ³¨å†Œæ¶ˆè´¹è€…
          IAsyncBasicConsumer consumer = new MessageConsumer(this._channel!);
          await this._channel!.BasicConsumeAsync(
              queue: "Q1",
              autoAck: false,
              consumerTag: "Email:Consumer",
              noLocal: false,
              exclusive: false,
              arguments: null,
              consumer: consumer,
              cancellationToken: stoppingToken
          );
          Console.WriteLine("MQ æ¶ˆè´¹è€…å·²æ³¨å†Œ!");

     }

     public override void Dispose()
     {
         
          base.Dispose();
          this._channel?.Dispose();
          
          this._conn.RecoverySucceededAsync -= this.RecoverySucceededAsync;
          this._conn.ConnectionShutdownAsync -= this.ConnectionShutdownAsync;
          
     }


}


```

>```csharp
>async Task M2(IConnection conn, CancellationToken token)
>{
>
>      MQBackgroundService service = new MQBackgroundService(conn);
>      await service.StartAsync(token);
>     
>}
>
>await M1(conn, CancellationToken.None);
>
>```
>
>
>
>



<!-- tabs:end -->
