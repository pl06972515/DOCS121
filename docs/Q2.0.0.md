<br/>

>[!WARNING|style: flat|label: 简要说明]
>
>- 默认情况下，`MQ`会尽可能快地将队列中的消息 [ 推送给所有已连接的消费者 ]
>
>  <span style='color:red'>[ 只要消费者的`TCP`连接和信道正常，消息会持续分发 - 直到队列为空或消费者的`TCP`缓冲区被填满 ]</span>
>
>⚠<span style='color:red'>[ 如果消费者处理能力有限且消息量激增，`MQ`可能会将大量消息推送到消费者，导致其内存和`CPU`占用过高，甚至可能引发进程崩溃 ]</span>
>
>```csharp
>public interface IChannel : IAsyncDisposable, IDisposable
>{
>
>      # [ 削峰限流 ] 控制消费端的消费速率 ( 以防止消费者被突发的大量消息压垮 - 保护下游系统的稳定 )
>      Task BasicQosAsync(uint prefetchSize,     // 默认: 0
>                         ushort prefetchCount,  // [ 预取消息数量 ] 削峰限流：即消费者在 Ack 前最多能收到多少条消息
>                         bool global,           // [ 是否全局设置 ] 一般用 false
>                         CancellationToken cancellationToken = default)
>
>}
>
>
>```
>
><br/>

```csharp
public sealed class MQBackgroundService : BackgroundService
{

     /*... 代码忽略 ...*/
     private async Task CreateAndStartConsumerAsync(CancellationToken stoppingToken)
     {

          this._channel?.Dispose();
          Interlocked.Exchange(ref this._channel, await _conn.CreateChannelAsync());
          var consumer = new MessageConsumer(this._channel!);

          # [ A ] 削峰限流 ( 最多 10 条未确认 )
          await this._channel.BasicQosAsync(prefetchSize: 0, prefetchCount: 10, global: false);

          # [ B ] 声明队列 Q1
          await this._channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);
          # [ C ] 注册消费者
          await this._channel!.BasicConsumeAsync(
              queue: "Q1",
              autoAck: false,
              consumerTag: "Email:Consumer",
              noLocal: false,
              exclusive: false,
              arguments: null,
              consumer: consumer,
              cancellationToken: stoppingToken
          );
          Console.WriteLine("MQ 消费者已注册!");

     }
   
}


```

