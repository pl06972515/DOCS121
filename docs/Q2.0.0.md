<br/>

>[!WARNING|style: flat|label: 简要说明]
>
>- (`RabbitMQ`) 在默认情况下：会尽可能快地将队列中的消息 [ 推送给所有已连接的消费者 ]
>
>  <span style='color:red'>[ 只要消费者的`TCP`连接和信道是畅通的，就会不断地把消息分发给消费者，直到队列为空或者消费者的`TCP`缓冲区满为止 ]</span>
>
>  <span style='color:red'>[ 如果消费者处理能力有限，而消息量突然激增，`RabbitMQ`会把大量消息推送到消费者端，导致内存、`CPU`占用过高，甚至进程崩溃 ]</span>
>
>```csharp
>public interface IChannel : IAsyncDisposable, IDisposable
>{
>      
>      # [ 削峰限流 ] 控制消费端的消费速率 ( 以防止消费者被突发的大量消息压垮 - 保护下游系统的稳定 )
>      Task BasicQosAsync(uint prefetchSize,     // 默认: 0
>                         ushort prefetchCount,  // [ 预取消息数量 ] 削峰限流：即消费者在 Ack 前最多能收到多少条消息
>                         bool global,           // [ 是否全局设置 ] 一般用 false
>                         CancellationToken cancellationToken = default)
>    
>}
>
>
>```
>
><br/>

```csharp
public sealed class MQBackgroundService : BackgroundService
{

     /*... 代码忽略 ...*/
     private async Task CreateAndStartConsumerAsync(CancellationToken stoppingToken)
     {

          this._channel?.Dispose();
          Interlocked.Exchange(ref this._channel, await _conn.CreateChannelAsync());
          var consumer = new MessageConsumer(this._channel!);

          # [ A ] 削峰限流 ( 最多 10 条未确认 )
          await this._channel.BasicQosAsync(prefetchSize: 0, prefetchCount: 10, global: false);

          # [ B ] 声明队列 Q1
          await this._channel.QueueDeclareAsync("Q1", durable: true, exclusive: false, autoDelete: false, arguments: null);
          # [ C ] 注册消费者
          await this._channel!.BasicConsumeAsync(
              queue: "Q1",
              autoAck: false,
              consumerTag: "Email:Consumer",
              noLocal: false,
              exclusive: false,
              arguments: null,
              consumer: consumer,
              cancellationToken: stoppingToken
          );
          Console.WriteLine("MQ 消费者已注册!");

     }
   
}


```

